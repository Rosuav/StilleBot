inherit http_websocket;
inherit builtin_command;
inherit annotated;
/* On-screen labels

Provides two things: a builtin and a display (and a config page). The display goes inside OBS. Like
with others, it should be authenticated by a key rather than by cookie. The config page exists to
manage the display.

The display is initially blank. It consists of a flexbox of labels.
- Each label has an ID, text, and some flags. It may have an expiration date.
- The (opaque) ID is autogenerated when the label is added ("lbl-" + sequential number)
- A label is automatically removed when its expiration date is reached.

The builtin creates a new label for the channel.
- Parameters: Text, duration, time-format
- Create a label and put {labelid} to the ID created
- Add duration onto time() to create expiration date. If zero duration, no expiration.
- If a time-format is selected, the label will be formatted with a countdown.
- Alternatively, remove an existing label. Internally it's the same builtin with parameters,
  but in command GUI it could be a separate element. Two parameters, {labelid} and duration -1.

Config:
- Text formatting (applies to all labels individually)
- Max labels (if one is created when at max, discard the oldest)
- Newest at bottom vs newest at top
- Link for OBS, and reset key

*/
constant markdown = #"# On-screen labels

TODO.
";

@retain: mapping channel_labels = ([]);

constant builtin_name = "Labels"; //The front end may redescribe this according to the parameters
constant builtin_description = "Create or remove an on-screen label";
constant builtin_param = ({"Text", "Duration", "/Countdown/=No countdown/ss=Seconds (eg 59)/mmss=Min:Sec (eg 05:00)"});
constant vars_provided = ([
	"{error}": "Error message, if any",
	"{labelid}": "ID of the newly-created label - can be used to remove it later",
]);

//Attempt to remove a label by its ID. Returns the ID if found.
string remove_label(string chan, string labelid) {
	mapping labels = G_G_("channel_labels", chan);
	foreach (labels->active || ({ }); int i; mapping lbl) if (lbl->id == labelid) {
		labels->active = labels->active[..i-1] + labels->active[i+1..];
		return labelid;
	}
}

mapping|Concurrent.Future message_params(object channel, mapping person, string|array param)
{
	if (stringp(param)) {
		//Compatibility with non-GUI command editor: allow a command string. Clunky but possible.
		sscanf(param, "%d %s", int dur, param);
		string timefmt = "";
		if (sscanf(param, "-mm %s", param)) timefmt = "mm";
		else if (sscanf(param, "-hhmm %s", param)) timefmt = "hhmm";
		param = ({param, dur, timefmt});
	}
	//Normally we'll be given an array of params.
	if (param[0] == "") return (["{error}": "Need a label to work with"]);
	string chan = channel->name[1..];
	mapping labels = G_G_("channel_labels", chan);
	string labelid;
	int duration = (int)param[1];
	if (duration == -1) {
		//Delete an existing label
		labelid = remove_label(chan, param[0]);
		if (!labelid) return (["{error}": "Label ID not found for deletion: " + param[0]]);
	} else {
		//Create a new label
		labels->active += ({([
			"id": labelid = "lbl-" + labels->nextid++,
			"bread": duration > 0 && time() + duration,
			"label": param[0],
			"timefmt": (<"mm", "hhmm">)[param[2]] ? param[2] : "",
		])});
		if (duration > 0) call_out(remove_label, duration, chan, labelid);
	}
	return ([
		"{labelid}": labelid,
		"{error}": "",
	]);
}

mapping(string:mixed) http_request(Protocols.HTTP.Server.Request req)
{
	//TODO: If fake, show something?? maybe?? Borrow ideas from alertbox demo mode.
	if (!req->misc->is_mod) return render_template("login.md", (["msg": "moderator privileges"]));
	return render(req, ([
		"vars": (["ws_group": ""]),
	]) | req->misc->chaninfo);
}

protected void create(string name) {::create(name);}
