* Per-channel rate limiting instead of the current one-per-second globally
  - Where the bot is a mod, the limit is three per sec. In other channels, must respect slow mode.
  - Is there a way to detect channel slow mode on connection? If it changes, there's a NOTICE.
    - Possibly ROOMSTATE, but I'm not receiving those.
* Variables.
  - NOTE: As of 2021-01-13, all variables are stored in persist_status->variables->#chan->$var$
    and any that aren't dollar-bracketed are buggy. This may change in the future, with
    the persisted mapping NOT having the dollar signs.
  - In variable management, allow variables to be deleted.
    - After check_for_variables, if it's been set to anything other than View, warn that
      it'll recreate the variable on next use.
    - Similarly, if it's been set to View, warn that the command won't work right after.
    - Scan for monitors too - they're the same as a view command
    - Allow cascading deletion
* Add some example/template commands that use cooldowns.
  - The functionality exists, but it can be used in a variety of ways. Good examples:
    - Short cooldown, no else. A simple squelch effect (command can't be used inside
      fifteen seconds).
    - Long cooldown, 'else' has alternate message. Command gives you some actual benefit,
      and you can only use it once every hour.
    - Very short cooldown (2 seconds), 'else' adds to variable and has output with a two
      second delay that emits everything from the variable. Will batch up busy responses.
  - And then there are the insane things that shouldn't clutter up the UI.
    - Attach event to !!cheer, !!sub, !!resub, !!subgift - ideally aliased
    - Send to !hypetrain. If {state} is not "idle", do nothing
    - Have five-minute timer on command
      - If command not on cooldown, keep silent
      - Else say "To start a hype train, we need just one more event within <time>"
    - Ideally, should stack the timeouts - each one starts an independent 5-min timer,
      and if any current timer is running, give the "else" message.
    - Can we recognize distinct people and ignore any doubled-up events?
    - This might require dedicated code. But it's fun to see how far we can go without.
* Across an update of connection.pike, retain the mod list, until such time as we get an
  updated list.
* Thank people for hosting (effectively a spam command triggered by a host notice)
  - Currently this is better done with Lisp Whispers, since distinguishing autohosts from
    explicit hosts requires authentication as the broadcaster.
* Pike HTTP, SSL, and keep-alive: what's going on? Is that why Chrome gets confused?
  - It's currently just disabled - we add "Connection: close" to all responses. Would
    be nice to figure out what's actually wrong and then reap the performance benefits.
* Go through all the web config pages and add user() to any user-defined text
* More specials!
  - Next song (VLC integration), incoming raid
  - Categorize them. The current specials would be "stream support" or something, and
    there could be categories for other things
* Allow the bot's commands to be individually enabled and disabled for a particular channel
  using the web interface. Would be subordinate to the active_channels feature, which gives
  a hard restriction and would prevent the command from showing up for enabling if it's not
  one of the specified channels.
  - For some commands (eg hypetrain), this can be done by shadowing with your own to disable,
    or to enable a hidden one, create one with the appropriate builtin.
* On the bot's emote list, allow search/filter by text
* Advanced timer functionality
  - If there's already a timer of this command happening, allow the user to pick whether it
    adds another independent one (current behaviour), restarts the timer (cancel existing
    and create new), or errors out with an immediate message of some sort.
  - Optionally emit message only if online at the time.
* Raid finder: Also show recent outgoing raids to allow notes to be added?
  - Or just "pick any channel, add notes". Have it show the stream as if in the raid finder.
  - The allfollows display could be this, but it's nondiscoverable and could be quite costly
    for people who follow a lot of people.
  - Adding ?raiders will show incoming, but not outgoing, raids.
* Move "$$autoform||$$" from markdown.html into each of the files that actually wants it
* Use persist_status->path("bcaster_token")[chan] for all need-more-auth calls
  - May need to track the scopes used in case they need to be enhanced
* Synchronize all deletion confirmation prompts. At the moment, I'm liking the wait/late
  system used in commands.js - keep the button about the same size, but disable it for a
  short timeout, after which it becomes enabled, after which it reverts to ground state.
* Importing of config export files
  - Ignore the active flag ("all" or "httponly")?
  - Create all listed commands, but don't destroy unmentioned ones (overwrite any with
    the same name, of course). Ditto specials, but whitelist the names, of course.
  - Identify triggers by their IDs, and merge accordingly.
    - What happens if they're in a different order? This is currently the only plausible
      way to reorder triggers, which might be significant.
  - Update timezone if specified.
  - What about quotes??? How do we validate their format?
    - Hand each one, individually, to the updater from the front end??
* Deprecate song requests, channel currency, and notice me
  - Ensure that there's no end-user-facing way to see any of them unless they're already
    active. Put warnings that they're on the way out.
  - Do I track viewership hours? That might be worth keeping even w/o currency.
  - This does not affect VLC integration, just song requests.
* Emote IDs must be strings
  - Existing code needs to switch from numbers to strings of digits
  - eg HypeTongue: emotesv2_ea658eb2e9d54833a4518c6dcc196dc6
  - rosuavLove: 390023
  - rosuavBarrel: emotesv2_e4ae2eaba06049e396e15e99a2554ccd
  - The URLs seem to be the same, as long as you include the prefix.
* Allow dialogs to be dragged around??
* Channel point redemptions triggering command-like responses
* Modules providing more specials - VLC integration can then trigger anything
  - Might be best to just code them all in addcmd still, but have them named usefully
  - Is the page getting too big? Does it need to be categorized?
  - What should 'person' be? What's the absolute minimum needed? If it's hard-coded, the
    value of $$ will be arbitrary, and that's fine; but what else might be looked for?
  - Don't bother deprecating report_track_changes as a config var. Just change the
    !song command to create, enable, or disable the special. Or maybe on first use, it
    creates a special with a condition based on a variable??
* MPN don't say changes saved if view HTML
