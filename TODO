* Per-channel rate limiting instead of the current one-per-second globally
  - Where the bot is a mod, the limit is three per sec. In other channels, must respect slow mode.
  - Is there a way to detect channel slow mode on connection? If it changes, there's a NOTICE.
    - Possibly ROOMSTATE, but I'm not receiving those.
* Variables.
  - NOTE: As of 2021-01-13, all variables are stored in persist_status->variables->#chan->$var$
    and any that aren't dollar-bracketed are buggy. This may change in the future, with
    the persisted mapping NOT having the dollar signs.
* Add some example/template commands that use cooldowns.
  - The functionality exists, but it can be used in a variety of ways. Good examples:
    - Short cooldown, no else. A simple squelch effect (command can't be used inside
      fifteen seconds).
    - Long cooldown, 'else' has alternate message. Command gives you some actual benefit,
      and you can only use it once every hour.
    - Very short cooldown (2 seconds), 'else' adds to variable and has output with a two
      second delay that emits everything from the variable. Will batch up busy responses.
      - Would be perfect in a !!giveaway_ticket special, or anything where it's normal
        for lots of people to use it all at once.
* Across an update of connection.pike, retain the mod list, until such time as we get an
  updated list.
* Pike HTTP, SSL, and keep-alive: what's going on? Is that why Chrome gets confused?
  - It's currently just disabled - we add "Connection: close" to all responses. Would
    be nice to figure out what's actually wrong and then reap the performance benefits.
* Advanced timer functionality
  - If there's already a timer of this command happening, allow the user to pick whether it
    adds another independent one (current behaviour), restarts the timer (cancel existing
    and create new), or errors out with an immediate message of some sort.
  - Optionally emit message only if online at the time.
* Raid finder: Also show recent outgoing raids to allow notes to be added?
  - Or just "pick any channel, add notes". Have it show the stream as if in the raid finder.
  - The allfollows display could be this, but it's nondiscoverable and could be quite costly
    for people who follow a lot of people.
  - Adding ?raiders will show incoming, but not outgoing, raids.
* Raid finder: Once the /streams endpoint starts reporting CCLs (the way /channels does),
  show this info on the tile somewhere.
* Importing of config export files
  - Create all listed commands, but don't destroy unmentioned ones (overwrite any with
    the same name, of course). Ditto specials, but whitelist the names, of course.
  - Identify triggers by their IDs, and merge accordingly.
    - What happens if they're in a different order? This is currently the only plausible
      way to reorder triggers, which might be significant.
  - Update timezone if specified.
* Is it possible to get a "recent messages" timeout? Would allow squishing of spam if the
  channel is too quiet. Might not be worth it though.
* Polish multi-voice.
  - This would allow the bot to see its own messages, but only if sent by a non-primary
    account.
  - Allow accounts to have a different default voice - probably just the channel's own.
    Then allow people to activate the bot, authenticate for self-voicing, and immediately
    start using bot features, with some restrictions, and with me able to lift those by
    granting them full permission.
  - Unify permissions for bcaster_auth and voice authentication
* Authentication on Firefox may now have issues with the default popup blocker. Can we
  comply with normal "click for popup" expectations somehow?
* Enable/disable rewards - allow use of title, will do lookup
* If you attempt to rename a command or add an alias that already exists (and isn't an
  alias for the current command), warn on client side and block save unless confirmed.
* Tidy up demo mode a bit.
  - Some pages have mutely nonfunctional buttons - they should announce that it's a demo.
  - Now that there's a sidebar showing all available features, it's the more important
    to have a viable demo page everywhere. Check - eg giveaway doesn't look good.
* Goal bar templates - nice easy ones that you can use right away
  - Note that Twitch now has on-platform goals that track current followers and subs,
    so this can continue to focus on how many have been gained recently (eg daily
    sub/resub count).
  - All of them will be usable out-of-the-box, but have "Advanced" that lets you fully
    customize the advancement. Also, if you REALLY need flexibility, they are backed by
    the variable system, so any command or special can move them around.
  - Make the advancement command a proper thing. It should be broadly possible to hack
    together a bit-boss kind of thing if you want to.
  - Standard goal bars:
    - Daily subs/resubs
    - Daily sub points (ie tiered subs count for more)
    - Daily cheers
    - All stream support (subs, resubs, cheers, all worth their USD equivalents)
    - Any others?
* Special trigger when any goal bar tiers up?? Would be better than the weird system
  where it triggers an actual command. Could deep link straight to the editor now.
* "max-width: fit-content" doesn't work in Firefox - but nor does -moz-fit-content :(
  - Causes display problems on graphical editor and opening up element details
* runhooks/register_hook is deprecated (use 'inherit hook'). Eventually remove it.
* Should ALL specials function as implicit arrays, the way triggers do?
  - Alternatively: should invocations and executions be separated? Aliases would then
    be just another way to have more than one invocation for a single command.
* With the shutdown of Kraken, can we record things locally that used to be on Twitch?
  - Followed games/categories - you can still follow/unfollow but you can't query it in API
* Need to enumerate all the places where a channel name gets used as a config key
  (outside of persist_config->channels->username) so they can be changed on rename.
  - persist_status->bcaster_token, bcaster_token_scopes
* Art Share tool
  - Implement !permit command for temporary single-use access
  - Mod command to nuke the last-posted file?
  - Anyone currently under timeout or ban is to be denied upload permission.
    - Need a way to grant authentication for this purpose.
  - Add link to the /channels/NAME/ landing page once it's ready for launch
* Dynamic rewards need a major rework. Once the above is done, maybe the builtin
  can do the dynamic updates too?
  - Change the Add New Dynamic to let you select any manageable reward first
  - If you don't pick one, then you can create new (optionally copying)
* Classic command editor is lagging behind a bit.
  - Set variable, "extra config", that sucks. The whole destcfg thing is a bit of a
    hack though, so I don't think it's worth going to any effort for this yet.
  - Mode "foreach" is also clunky, plus it can't have the participant_activity set.
* GUI editor - params need formatting options, in and out
  - Builtin params need to cope with splitting strings to arrays
* Rename "gifted" flag in sub alerts to "is_gifted" to trigger boolean handling
  - Migrate existing settings
* Replace bcaster_token[name] with user_token[id] and ditto scopes
  - Use the helper functions token_for_user_{id,login}{,_async} to get user creds
  - These all return (or yield) an array ({token, scopes}) or 0 if no creds.
* Alertbox: For any non-personal alert, have a "Revert to Stock" which deletes the
  alert settings that you have, aside from the "Active" flag
  - It may be worth having Active be a single-attribute update, so when you toggle
    activation status, it doesn't save everything else.
  - When an alert does not have any other details set, it uses a stock alert. Thus
    you can easily enable and disable alerts, without having to do the work of
    creating them. (I think they should start enabled?)
* Find all forms in dialogs and use tag=formdialog instead
* Somewhere in either giveaway or pointsrewards, something attempts to query the
  rewards for Mustard Mine, which bombs with a 403 (b/c not affiliate). Track it
  down at some point; may need to add some instrumentation.
* Have an image that people can use to link to the bot's landing page, if they
  wish to give credit.
* Before Aug 3rd, complete the changeover to follower requests with authentication
  - See poll.pike and comments regarding this date
* Other support platforms? Which ones have integrations available?
  - Should /kofi be renamed and grow all the others?
  - Throne?
* Seek verification status.
  - https://dev.twitch.tv/limit-increase
  - Requires a panel on the bot's channel saying:
    (1) Owner contact information,
    (2) Bot description,
    (3) Instructions on how to add the bot to a channel, and
    (4) Instructions on how to remove the bot from a channel
  - Appeal to Twitch for the name StilleBot? If it can be made available, activate it as
    another voice, and maybe make it the new default. Otherwise use MustardMine.
* Bot sharding. What would it take?
  - MUST NOT disrupt external usage eg URLs
  - Each channel will need to stay together, meaning that all shards will need IRC and
    web connections
  - User preferences must be non-sharded; if you are using multiple channels, prefs are
    still synchronized across them.
  - Must be dynamic. This will allow bot restarts to happen progressively by adding and
    removing shards.
  - Might require a single central dispatcher. This is a minor problem but not huge (at
    the moment). Maybe the dispatcher can be the same code as any other shard, with some
    way to know "there are other shards over there and there"?
    - If possible, the central dispatcher should be able to move. Might require some
      careful handling though.
  - Incoming webhooks have to be dispatched to the shards
  - Updates to persisted info need to be centralized. This may predicate this on a config
    system built on something other than JSON files. Maybe move to PGSQL?
  - May be of lower importance now that the IRC connection can be sharded within a single
    process; this is no longer a startup performance concern, but a reduction in outages
    and potential geographic sharding.
* Consider changing the font used everywhere, to improve consistency (default font seems
  to vary in size btwn Chrome and Ff).
  - Possible font options: Lato, Nunito, Prompt, Hind
* Create a command in the MustardMine channel (and StilleBot if it gets granted to me) to
  add the bot to the user's channel. Note that, if a person misbehaves and the bot gets
  deauthenticated from their channel, all I have to do is ban them from #mustardmine and
  the bot will never need to worry about reactivation.
  - Note that this will mean that this is a canonical list of banned users and thus should
    be queried (by API) if ever there is the need to do so.
* Similarly, a command to remove the bot from a channel
  - Instead of immediately deleting all data, though, flag the channel as "deactivated",
    and purge after some delay (eg a week). If the channel is reactivated in that time,
    all data should be kept.
  - Or should data be kept permanently, and have a separate "delete my data" action?
* Per-channel per-user data
  - Variables - can use "$*foo$" or "$49497888*foo$" for explicit UID
    - Support this notation for cooldowns too?? Including aliasing via the builtin.
  - Channel currency?? Would become available as "*points" but automatically incremented
    according to rules like "+1 every 5 minutes to all in chat".
    - It's now possible to do this manually (have an automated command that adds to a
      variable for each chatter), but would be convenient to configure it in one place.
* Block bad variable names (those with "$|{}") on the front end - on the back end, those
  characters will be silently stripped out.
* Identify whispers better
  - When a whisper comes in, be sure we know which voice received it
  - Allow whispers to trigger commands in some per-channel way
    - Channel config->whispers_as_commands - no current way to set it
    - What about secondary voices? For example, whispering CandiCat could execute commands
      in #devicat and then whisper the response from CandiCat.
* Once all usage of channel->name, channel->name[1..], (string)channel->userid in any
  persist query is done through path() or has_path(), transform them into abstract lookups.
  - Can use persist_status->path("some_keyword", channel, "whatever")
  - Keep the existing lookups unchanged for stability. Monitor to ensure that nothing breaks.
  - Eventually, rename all to use the userid - no code should break.
    - Should™.
* Eventually, move persist_config to a directory of config files, one per channel, with a
  global config for things that don't apply to one channel. Save into channels/49497888.json
  with globals remaining in twitchbot_config.json for now.
  - Both are currently supported; existing data can be migrated when safe.
* Eventually, move all per-user config out of persist_status into a directory, similarly.
  For example, persist_status->bcaster_token->rosuav would now become users/49497888.json
  with a key of user_token (see above re other changes there).
  - Note that anything that isn't clearly one single user's data (such as raids) can stay
    where it is.
* Migrate channel info out of persist_status into channel config
* Allow users to take a backup of their full config?? Currently the "Backup Settings" thing
  is designed to have consistent format so people can git-manage it, but if I move stuff
  from persist_status into there, it might not work so well for that. Or maybe I keep the
  current "settings" backup but have a separate thing for a GDPR-style "request my info"?
  Not sure that I want to dig into the full details of GDPR, and I definitely don't want to
  imply that I have if I haven't.
* Make the GUI command editor more accessible
  - GET A SCREENREADER and see how everything sounds. If needed, adjust.
    - Orca sucks. What others are there?
* Should Favourites become a tray like any other??
* Raid finder "share status"
  - Option: "Share status with potential raiders"
  - If enabled, when you open the raid finder, it signals all raid finders who have you
    as a tile. Red asterisk to signal "Has raid finder open, is probably ending soon!"
  - Similarly, when you close the raid finder (or disable the option), signal-revert all.
* chan_features - add a thing for broadcaster scopes, eg for !follower, !hypetrain
  - Group them. Put a note on the ones that require it. If they are active, have a single
    button to reauthenticate.
  - This might need to scan ALL commands for any use of builtins flagged as requiring scope.
  - Back end work is largely sorted, except that stashing it in prefs might not be right.
  - We need to show this info primarily to the broadcaster, but also to mods, so that they
    know that some commands might not be fully functional (yet), and can advise the caster
    to go to that page to authenticate (as per /hypetrain).
  - This means that, on the chan_features page, it may need to show the channel's info re
    missing perms, the user's info ditto ditto, or both.
* Instead of deleting a channel's config, flag it as Inactive
  - This flag probably shouldn't go in the channel config file, since that would require
    loading every config file to determine which ones to not bother loading.
  - Instead, we may need metadata in persist_status, indicating which channels are active.
  - Ensure that newly-added channels are immediately active
* Cron job to track channels that have been inactive for a long time (maybe 2 weeks) to
  archive and eventually dispose of their configs
* Make connection priority dynamic
  - Inactive/deleted channels are excluded already
  - But idle channels should have nearly as low a cost
  - If a channel has been live within the past two weeks, it has "regular" priority
  - If it's in my notify list, "high" priority??
  - Maybe allow modules to add to an array of "reasons for priority"?
* During update of window.pike, sometimes seeing this:
  (stillebot.pike:535692): GLib-GObject-WARNING **: 10:15:44.496: ../../../gobject/gsignal.c:2732: instance '0x55b0f70e9970' has no handler with id '4781'
  - Probably indicates a signal connected to an object, object gets destroyed, then
    signal gets removed.
* Instead of looking up in G->G->irc->channels["#" + channelname], prefer G->G->irc->id[id]
  - Though channels[] isn't going anywhere. There's too much that needs the name lookup,
    and it's not worth the churn to remove the hashes.
* Headless mode
  - Need a way to trigger a code reload (SIGHUP?)
  - Maybe have a way to add and remove channels
  - Enable/disable Localhost Mod Override
* Command search (including triggers and specials)
  - eg After an emote got renamed/removed, search for all usage
  - Be naive. Don't bother excluding things with destinations.
  - Search results should have the normal command editor gear for editing, but instead
    of having the editable command, show the path to the match(es)
* Bit Boss???
  - Alternate display mode for a goal bar: "Hitpoints".
  - As the value advances toward the goal, the display reduces, ie it is inverted
  - Use the "level up command" to advance to a new person
  - Have an enableable feature that gives:
    - Goal bar, with variable "bitbosshp" and goal "bitbossmaxhp"
    - Level up command that sets "bitbossuser" to $$, resets bitbosshp to bitbossmaxhp,
      and maybe changes bitbossmaxhp in some way
      - Note that "overkill" mode can be done by querying the goal bar before making changes
    - Stream online special that initializes everything
    - Secondary monitor that shows the user's name and avatar??? Or should there be two
      effective monitors in the same page?
* Channel error log
  - Find other places that should be reporting errors and make them report.
    - We need to talk to you about your TPS, error, and warning reports.
  - Fully implement unread status - lift code from chan_messages as needed.
* Database configs???
  - Parallel stillebot databases on Sikorsky and Gideon
  - Initiate replication from Sikorsky (PG 15) to Gideon (PG 12)
  - Attempt reverse replication - may fail due to version conflict
  - Experiment with failover
  - Normal operation will either be:
    - Sikorsky runs PG in "publish" mode and runs StilleBot; Gideon runs PG in
      "subscribe" mode and does not run StilleBot
    - Or Gideon runs "publish" and the bot, Sikorsky does not run; followed by
      Sikorsky running in "subscribe" mode and run StilleBot; followed by a
      return to primary mode.
  - We won't get to this state any time soon but aim towards it.
  - https://www.postgresql.org/docs/current/logical-replication.html
  - Note that running StilleBot on Gideon requires ../pike9/bin/pike
  - Ideally, replication should use both server and client SSL certs, making use of
    the same certs StilleBot uses for both sikorsky.rosuav.com and gideon.rosuav.com.
* Database transfer procedure
  - Initially, Sikorsky is read-write, Gideon is read-only.
    - TEST: That we can mark the DB as read-only, but happily connect.
  - I choose to bring Sikorsky's DB down.
  - Sikorsky's DB becomes read-only
    - TEST: That we can mark the DB as read-only while existing connections and
      transactions exist.
  - Wait until there are no open read-write transactions
    - TEST: That we can detect read-write transactions while permitting read-only
  - Reverse the direction of replication
    - TEST: That replication can occur in either direction and be started and
      stopped independently; OR that replication can concurrently exist in both
      directions without conflict (assuming one database is read-only).
  - Mark Gideon's DB as read-write
    - TEST: That StilleBot can detect that read-write transactions are denied
  - StilleBot connects to Gideon and pushes out any pending changes
  - Notifications require a level of protocolling.
    - Connect using application_name "stillebot"
    - Query "show default_transaction_read_only"
    - If result is "off":
      - Query "listen readonly" and set_notify_callback
      - Query "show default_transaction_read_only". If result is "on", immediately
        disconnect and start over - race condition has happened, database JUST went
        into read-only mode.
      - Current connection is active.
    - If result is "on":
      - Query "set application_name = 'stillebot-ro'"
      - Attempt connection to other database, using same logic
      - If both are read-only, queue all changes and periodically attempt reconnection
        - Note that querying CAN be done in this state, and from the user's perspective
          so can changes, but they will be vulnerable to a crash until the other is up.
      - Otherwise, whichever is read/write is active, and the other can be closed.
    - Upon receipt of notification on the "readonly" channel:
      - Ensure that there are no active transactions
      - Disconnect from the active database, attempt reconnection according to original
        logic. This will likely result in a switchover, but there may be a both-read-only
        period. Note that a notification on "readonly" may indicate the END of read-only
        mode, and the reconnection might now allow us to go read/write.
* Multi-homing.
  - Have reserved the names stillebot.rosuav.com and stillebot.com for this purpose.
  - Need to set up a redirect on Gideon: if a certbot request comes in, 302 it to
    http://sikorsky.rosuav.com/...... for the actual resolution.
  - Need to synchronize the cert on both systems. Probably needs something in the
    deploy script to scp the key/cert to Gideon.
  - Once all configs are in database, it should be possible to host that in one
    place and connect to it from multiple.
  - Just like with sharding, incoming webhooks will need to be handled properly.
* Sometimes the connection will fall over, and the bot won't be aware of this.
  Need a way to "force disconnection" which basically just overrides the irc_connect
  retention rules (same as a version mismatch does). Is it worth trying to do this
  automatically, or just have a menu item for it?
* Whenever you save/overwrite a command, log the previous version somewhere for an
  "Undo" feature?? It's now very possible to accidentally delete slabs of content,
  or even the entire command.
* MustardScript enhancements
  - Look into making a syntax highlighter config
* Redirect /channels/NotFlatCase/ to lowercase
