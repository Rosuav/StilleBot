* Per-channel rate limiting instead of the current one-per-second globally
  - Where the bot is a mod, the limit is three per sec. In other channels, must respect slow mode.
  - Is there a way to detect channel slow mode on connection? If it changes, there's a NOTICE.
    - Possibly ROOMSTATE, but I'm not receiving those.
* Song request by search??? (eg "!songrequest blargh" to search Youtube for "blargh")
* Variables.
  - NOTE: As of 2021-01-13, all variables are stored in persist_status->variables->#chan->$var$
    and any that aren't dollar-bracketed are buggy. This may change in the future, with
    the persisted mapping NOT having the dollar signs.
  - In variable management, allow variables to be deleted.
    - After check_for_variables, if it's been set to anything other than View, warn that
      it'll recreate the variable on next use.
    - Similarly, if it's been set to View, warn that the command won't work right after.
    - Scan for monitors too - they're the same as a view command
    - Allow cascading deletion
* More types of conditional messages.
  - Cooldown (global or per person). Set at the top level - wouldn't apply to
    subcommands - would automatically manage the CD and "then" means "not in cooldown",
    with "otherwise" meaning "in cooldown". A few ways to use that:
    - Short cooldown, no else. A simple squelch effect (command can't be used inside
      fifteen seconds).
    - Long cooldown, 'else' has alternate message. Command gives you some actual benefit,
      and you can only use it once every hour.
    - Very short cooldown (2 seconds), 'else' adds to variable and has output with a two
      second delay that emits everything from the variable. Will batch up busy responses.
* Across an update of connection.pike, retain the mod list, until such time as we get an
  updated list.
* Thank people for hosting (effectively a spam command triggered by a host notice)
  - Currently this is better done with Lisp Whispers, since distinguishing autohosts from
    explicit hosts requires authentication as the broadcaster.
* Pike HTTP, SSL, and keep-alive: what's going on? Is that why Chrome gets confused?
  - It's currently just disabled - we add "Connection: close" to all responses. Would
    be nice to figure out what's actually wrong and then reap the performance benefits.
* Go through all the web config pages and add user() to any user-defined text
* Use the "special responses" system to customize texts like shoutouts? Would need a way
  to provide default text, and then explicitly removing it would mean "don't do this".
* Allow commands to contain spaces. They cannot ever be invoked that way, but some commands
  could look for them, so for instance shoutout.pike could look for "!so someusername" and
  if found, use that text instead. (Thanks Mirror for the idea!)
* More specials!
  - Next song (VLC integration), stream now live, incoming raid
  - Categorize them. The current specials would be "stream support" or something, and
    there could be categories for other things
  - Maybe incorporate shoutouts and specific shoutouts into this?
* Allow the bot's commands to be individually enabled and disabled for a particular channel
  using the web interface. Would be subordinate to the active_channels feature, which gives
  a hard restriction and would prevent the command from showing up for enabling if it's not
  one of the specified channels.
  - Would be good for the !hypetrain command, especially, since it could then be activated
    independently to the allcmds status (cf DeviCat).
  - Maybe have (separate to allcmds) a "web-and-echocommands" status? It'd allow mods to
    use all the features of the web interface, but wouldn't activate allcmds. Or maybe that
    would turn out to be identical to "allcmds on, but then disable each command".
* On the bot's emote list, allow search/filter by text
* Advanced timer functionality
  - If there's already a timer of this command happening, allow the user to pick whether it
    adds another independent one (current behaviour), restarts the timer (cancel existing
    and create new), or errors out with an immediate message of some sort.
  - Optionally emit message only if online at the time.
* Raid finder: Also show recent outgoing raids to allow notes to be added?
  - Or just "pick any channel, add notes". Have it show the stream as if in the raid finder.
  - The allfollows display could be this, but it's nondiscoverable and could be quite costly
    for people who follow a lot of people.
  - Adding ?raiders will show incoming, but not outgoing, raids.
* Move "$$autoform||$$" from markdown.html into each of the files that actually wants it
* Use persist_status->path("bcaster_token")[chan] for all need-more-auth calls
  - May need to track the scopes used in case they need to be enhanced
* Synchronize all deletion confirmation prompts. At the moment, I'm liking the wait/late
  system used in commands.js - keep the button about the same size, but disable it for a
  short timeout, after which it becomes enabled, after which it reverts to ground state.
* Additional command destination: "/builtin"
  - Needs a target such as "!so %s"
  - Will hand this branch of command to the corresponding builtin by setting it into
    person->outputfmt or something
  - Not all commands will support this. That's fine. Those that don't will simply do
    their own thing, regardless of the provided outputfmt.
  - ONLY built-in commands are supported, and ONLY those that have no active_channels
    flag. This means they will be found in G->G->commands[cmdname] with no punctuation.
  - If person->outputfmt is set, check_perms will bypass all checks and go straight
    to process(). This allows aliases to be used for mod-only commands. It's up to the
    mods to choose what aliases exist, so you can make a mod-only alias, or you can
    choose to make this available to everyone.
    - Don't shortcut with function_object(cmd)->process - it would break things like
      !unrepeat that insert alternate functions into commands[].
    - If anything ever recreates the checks in check_perms, it'll need to be checked.
  - Supported commands will have a default execution format that is used if outputfmt
    isn't set. It will likely be parameterized. (Those parameters will therefore be
    available to the outputfmt one as well.) This default format will be made visible
    somewhere so that it can be added to the complex template list, eg:
    - !so ==> (["dest": "/builtin", "target": "!so %s", "access": "mod", "message": ...])
    - Can this be fully generated from the command itself? Maybe have a separate
      inherit for "builtin_command" or a "constant builtin_command = 1;" that adds it
      to the list.
    - Probably an inherit (which will itself inherit command, of course). It'll add a
      function to be called with the appropriate parameters, and will use the default
      format or the specified one.
    - Anything not in this list is unavailable. Maybe just not worth handling !unrepeat?
